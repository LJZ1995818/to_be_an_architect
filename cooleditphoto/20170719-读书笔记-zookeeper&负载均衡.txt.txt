大型分布式网站架构设计与实践第一章 读书笔记
1.RPC主要包括服务提供方和服务调用方，在集群中还需要路由和负载均衡
2.rpc协议有基于HTTP的和TCP的
3.HTTP协议的rpc的请求包括编码、命令和命令长度三个字段，响应包括编码、响应内容、响应内容长度三个字段
4.SOA架构中，服务消费者通过服务名称，在众多服务中找到要调用的服务的地址列表，称为服务的路由。
5.负载均衡与ZOOKEEPER
  5.1 服务配置中心负责服务的动态注册以及获取服务信息
  5.2 服务消费者只有在第一次调用时访问配置中心，之后会使用本地缓存的服务地址列表，除非服务信息有变化
  5.3 负载均衡算法主要包括轮询法、随机法、最小连接数法等。
      有一个serverweightmap的Map变量来表示服务器地址和权重的映射，在实现负载均衡算法时，需要先新建局部变量serverMap，将域变量serverweightmap复制到线程本地，以避免并发问题
  5.4 轮询法：需要用到synchronized关键字，以防止不同线程修改位置变量pos值，因此性能不好
  5.5 随机法：分配到某一个地址的比例的效果会趋近于轮询法，性能优于轮询法
  5.6 源地址哈希法：同一IP地址的客户端，当后端服务器列表不变时，会被映射到同一后端服务器。
  5.7 加权轮询法：考虑服务器的配置和负载，加入权重，其他类似轮询
  5.8 加权随机法：考虑服务器的配置和负载，加入权重，其他类似随机法
  5.9 最小连接数法：动态地选择当前积压连接数最小的一台服务器
6.zookeeper通过zab协议保持数据一致性
7.zookeeper的节点叫做znode，znode除了包含数据外，还可能有子节点，当节点上的数据和子节点发生变化时，基于watcher机制，会发出相应的通知。
8.为了监控服务提供者和服务消费者，每个服务包含consumer和provider两种节点类型

大型网站核心架构——核心原理与案例分析 李智慧 
1.网站架构模式
  1.1 分层：但是分层架构也有一些挑战，就是必须合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，禁止跨层次的调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或者服务层调用应用层）
  1.2 分割：横向
  1.3 分布式：服务调用必须通过网络，数据一致性很难保证
  1.4 集群
  1.5 缓存：将数据存放在距离计算最近的位置以加快处理速度 使用缓存有两个前提条件：1.数据访问热点不均衡；2.数据在某个时间段内有效，不会很快过期，否则缓存的数据就会因失效而产生脏读，影响结果的正确性。
  1.6 异步：将一个业务操作分成多个阶段，异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常有利
  1.7 冗余
  1.8 自动化
  1.9 安全：XSS攻击，SQL注入

2.session：负载均衡需要无状态性，然后需要session记录上下文请求内容。
  2.1 session复制
  2.2 session绑定
  2.3 利用cookie记录session
  2.4 session服务器

3.高可用服务策略
 3.1 分级管理
 3.2 超时设置
 3.3 异步调用
 3.4 服务降级
 3.5 幂等性设计：应用调用服务失败后，会将调用请求重新发送到其他服务器，但是这个失败可能是虚假的失败。
     比如服务已经处理成功，但因为网络故障应用没有收到响应，这时应用重新提交请求就导致服务重复调用，如果这个服务是一个转账操作，就会产生严重后果。
     幂等性：因此必须在服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性。
 
4.高可用数据：数据备份和失效转移机制

PAXOS算法
一系列过程都可以提供值，一个一致性算法确保只有一个值被选出，一个值被选出后，所有的进程应该都能知道。
整个一致性算法有三类代理，proposers,acceptors,learners
代理有可能失败、重启，如果信息不能被保存，那么就会出问题
信息可能被delivered,duplicated,lost,not corrupted
选择一个值
1.有唯一一个acceptor agent，选择第一个来的proposed value，但假如acceptor出问题，后面就全完
2.用多个acceptor agents，一个acceptor会选择大部分acceptors选择的proposed value，一个acceptor最多只能选择一个值
Principal 1:多个proposer会在同一时间propose不同的值，这会导致没有一个多数同意的值(?)。在这种情况下,必须允许一个acceptor接收多个proposed value，给每一个proposal设定一个自然数（这个自然数之后被翻译为为请求值)。
Principal 2:如果一个值为v的proposal被接受，那么请求值比这个proposal大的值都是v
把P2强化到P2a，P2b
P2b如果一个值为v的proposal被选中，则任何标记值更大的请求的值都是v

整体过程：
1.一个proposer 把的数值n发送给一些acceptors，收到回复：1.承诺不在接收比请求值n小的；2.之前的值比n小的最大的proposal
这被称作一个n值的准备请求
2.proposor从大部分acceptor那里收到了回复，之后他可以提出请求包括数值n，值v，v是回复中最大数的proposal，如果没有proposal，则为任意值

优化一下，为如下过程
第一阶段：
a.一个proposor选择一个请求值n，然后发送准备请求（prepare request）给大部分acceptor
b.一个acceptor接收了一个准备请求，这个请求中的n值比之前准备请求的n值大，则之后他会返回一个回复，承诺不再接收请求值比n值小的proposal，并且把现在请求值最大的proposal也返回去
第二阶段：
a.如果一个proposor从大多数acceptor那里收到了回复，之后会发送一个accept请求给这些acceptors，这个accept请求包含一个请求值n，以及一个值为v，这一个值是得到的回复中请求值最大的请求包含的值，如果这些从acceptor返回的回复
中没有proposal，则为任意值
b.一个acceptor接收一个accept请求后。如果之前没有回复给一个标记值大于n的准备请求，则它会接受此请求。












