锅包肉包锅

本周总结关于java虚拟机
判断对象是否存活：
1.引用计数算法：给对象中添加一个引用计数器，当一个地方调用它时，计数器就加一，当引用消失时，计数器就减一；
当两个对象相互引用的时候（没有其他任何引用），理论上可以造成死循环而被回收，实际上还是会被回收，java虚拟机并不是依靠引用计数来判断对象是否存活的。
2.可达性分析算法：通过"GC Roots"的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链
当一个对象到GC Roots没有任何引用链相连时，证明这个对象是不可用的。

引用分为：强引用，软引用，弱引用，虚引用
1.强引用：垃圾回收器永远不会回收它，当内存空间不足时，宁可抛出OOM也不会回收。
生命周期：jvm停止运行时终止
2.软引用：内存空间足够，垃圾回收器就不会回收它；当内存空间不足，就回收这些对象的内存。
SoftReference类实现它，可应用内存敏感的高速缓存
软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
生命周期：内存不足时终止
3.弱引用：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
WeakReference类实现它
当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，你就使用弱引用。
生命周期：gc运行后终止
4.虚引用：它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
PhantomReference类实现
生命周期：

垃圾收集算法：
标记――清除：标记要回收的对象，标记完成后统一删除
优点：容易实现
缺点：效率低，会产生大量的不连续的空间
标记――整理：让所存活的对象都向一端移动，然后清除掉边界以外的内存
优点：不会浪费内存，也不会产生大量空间碎片
缺点：效率低
复制：分成两块区域，每次只是用一个，当这一块用完了，将存活的对象复制到另一块区域中，然后清理掉用完的区域。
优点：效率高
缺点：浪费内存
商业虚拟机采用一块较大的Eden和两块较小的Survivor，比例是8：1
当内存不够用时会采用担保机制

垃圾收集器：
1.年轻代收集器
Serial收集器：单线程收集器，简单高效
ParNew收集器：多线程收集器
并发：一个处理器处理多个任务，交替运行
并行：多个处理器同时处理多个任务
Parallel Scavenge收集器：一个注重吞吐量，适用于后台运算不需要太多交互的任务
虚拟机会根据当前系统的运行情况，GC自适应的调节策略
2.老年代收集器
Serial Old收集器：单线程
Client模式下的虚拟机，常与Parallel Scavenge连用
Parallel Old收集器：吞吐量优先，只能搭配Parallel Scavenge
CMS收集器：应用做多的收集器
初始标记――》并发标记――》（1.5后并发预处理）――》重新标记――》并发清除
缺点：
a.对CPU资源敏感，不少于25%的CPU资源
后来提供一种"增量式并发收集器"i-CMS"减少独占资源，但垃圾回收过程更长，效果很一般，不建议使用
b.无法处理浮动垃圾，出现Concurrent Mode Failure失败，导致另一次Full GC产生，启动后备预案Serial Old
c.由于采取标记――清除算法，产生大量的空间碎片，无法为大对象分配连续空间
3.G1收集器：
停顿的时间并发Java程序继续进行
不同方式处理新对象，已经存活一段时间，多次GC的旧对象
标记――整理算法
可预测停顿

类加载机制
加载、验证、准备、解析、初始化、使用、卸载
加载：取得类的二进制流、转为方法区数据结构、在Java堆中生成对应的java.lang.Class对象
验证：文件格式的验证、元数据验证、字节码验证、符号引用验证
准备：分配内存，并为类设置初始值 
解析：符号引用替换为直接引用
初始化

类加载器
双亲委派模型：向上委派，向下加载
四种类加载器：
BootStrap ClassLoader （启动ClassLoader）
Extension ClassLoader （扩展ClassLoader）
App ClassLoader （应用ClassLoader/系统ClassLoader）
Custom ClassLoader(自定义ClassLoader)

手抓饼，辛苦了



