可乐加薯片

MySQL技术内幕InnoDB存储引擎笔记（未完）

MySQL属于单进程多线程架构。

观察mysql数据库启动后进程的启动情况的命令：ps -ef | grep mysqld
查看MySQL数据库实例启动时会在那些位置查找配置文件的命令：mysql –help | grep my.cnf 以读取到最后一个参数为基准

数据库和数据库实例是不一样的，用户通过数据库实例操作数据库文件。

数据库体系结构：
Connectors（Native C/JDBC/ODBC等） –> Connection Pool(连接池：链接处理，安全验证) –> 查询缓存/分析器 - 优化器 （1.查询分析/优化/缓存/内置函数 2.内建视图/存储过程/触发器） –>Pluggable Storage Engines(插件式存储引擎) –>数据表

可以通过修改存储引擎的源码从而达到例如添加辅助SSD缓冲池，从而通过利用SSD的高随机读写性能来进一步的数据库本身的性能。

InnoDB的功能：行锁设计 支持外键 支持全文索引 支持非锁定读（默认读取不会产生锁）
数据在一个逻辑的表空间（待补充和MyISAM的区别）
事物的隔离级别默认是REPEATABLE级别 使用一种next-keylocking来避免幻读的产生
其他特点：插入缓冲/二次写/自适应哈希/预读/异步IO/刷新临接页等
表中的数据是通过聚集的方式进行存储的，每张表的数据是按照主键的顺序进行存放数据，如果表中没有显示的声明主键，InnoDB存储引擎会为每一行生成一个6字节的rowid,并以此作为主键

MyISAM的功能：表锁设计 不支持事物 支持全文索引 缓冲池只缓冲（cache）索引文件，而不缓冲数据文件，数据文件交给操作系统本身来完成（而不是像其他数据库系统一样依靠LRU算法进行缓存数据）
由MYD存放数据 MYI存放索引

常用的进程通信的方式：管道/命名管道/命名字/TCP/IP套接字/UNIX域套接字

MySQL一般都是同过TCP/IP套接字连接

后台线程主要作用是负责刷新内存中的数据，保证缓冲池中的内存缓存是最新的数据，并将已修改的数据文件刷新到磁盘文件中，同时保证在数据库发生异常的时候InnoDB能够恢复到正常运行的状态。

后台线程的分类：
1.Master Thread：一个核心的后台线程，负责将缓冲池中的数据异步刷新到磁盘中，保证数据的一致性 包括脏页面的刷新，合并插入缓冲，UNDO页的回收
2.IO Thread：MySQL中有大量的AIOThread，负责这些IO请求的回调处理 （write 4/read 4/insert buffer 1/log IO thread 1 四种）
3.Purge thread：事物提交后，回收已经分配的undo页面（undo页面：为了满足事物的原子性，在做任何操作的时候将数据备份到undo页面 UNDO log，然后进行修改，如果发生错误或者用户rolback，则利用undo log将数据恢复到刚开始之前
redo log：Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。 ）
4.Page Cleanner Thread:将之前脏页面的刷新放入到单独的线程进行，从而减轻Master thread的工作以及对于用户的阻塞，进一步提高MySQL的性能。

内存：
1.缓冲池：将页fix到缓冲池中（一块内存区域）–> 下次读取看是否在缓冲池中命中 –>不命中才从磁盘上读取
对于数据库的修改先在缓冲池中修改好，然后再以一定的频率刷新到磁盘上（使用的是CheckPoint机制）
2.LRU算法 / 列表（改良了的）：传统的朴素LRU算法会使得进行索引或者数据的扫描操作的时候将一部分不活跃热点数据的页面加入到LRU的最前面导致热点数据从LRU列表中被删除。（普通的是free列表 还有待flush的列表）

脏页面即缓冲池中的页面和磁盘上的页面的数据不一致。会将flush列表中的脏页面刷入磁盘中。

重做日志缓冲：重做日志信息–>重做日志缓冲–>重做日志文件

当数据改变时：采用的是write Ahead Log策略 ： 事务提交–>重做日志–>修改页面 当服务宕机的时候，通过重做日志恢复数据，保证了ACID的D（Durability持久性）

CheckPoint技术：
1.缩短数据库的恢复时间
2.缓冲池不够的时候将脏页面刷新到磁盘，之后就能够将重做日志覆盖
3.重做日志不可用的时候刷新脏页面

当页面溢出LRU的页面的时候，如果页面是脏页面，需要强制执行CheckPoint，将脏页面刷新到磁盘
